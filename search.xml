<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python基础(十一)]]></title>
    <url>%2F2014%2F12%2F15%2Fpython%E5%9F%BA%E7%A1%80(%E5%8D%81%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[面向对象和类面向对象面向对象,简单来说用类对一切对象进行描述的一种编程思维和方法.在这里就不多做介绍(因为我也只是意会到一点点).根据面向对象的概念,我们需要注意的几个概念: 类(Class): 用来描述具有相同的属性和方法的对象的集合.它定义了该集合中每个对象所共有的属性和方法. 对象(Object)：通过类定义的数据结构实例.对象包括两个数据成员（类变量和实例变量）和方法。 类变量：类变量在整个实例化的对象中是公用的,类变量定义在类中且在函数体之外,类变量通常不作为实例变量使用. 实例变量：定义在方法中的变量,只作用于当前实例. 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法：类中定义的函数. 继承：即一个派生类（derived class）继承基类（base class）的字段和方法.也称为父类和子类 方法重写：如果从父类继承的方法不能满足子类的需求,可以对其进行改写. 实例化：创建一个类的实例,类到具体对象的过程 属性: 不管是变量或者是方法,都称为属性.变量一般称为静态属性,方法称为动态属性 面向对象的三大特性 1, 封装: 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏. 2, 继承: 让不同类型的对象获得其它类型对象的属性和方法. 3, 多态: 实现接口重用, 即可以不同类型对象使用相同的方法,也可以一个对象的相同方法在不同情形有不同的表现形式 类类的封装,基本构成和使用1, 创建类,先来看例子 1234567class Test(object): &apos;&apos;&apos;class_doc&apos;&apos;&apos; class_var = &apos;class_var&apos; def class_func(self): obj_var = &apos;obj_var&apos; print(obj_var) 1234567class | 定类的关键字通常类的首字母使用大写object | 新式类的所有类的基类,经典类和新式类在后面阐述,python3中建议使用这种形式定义类class_doc | 类的文档,可以通过__doc__方法查看obj_var | 实例变量,需要对类进行实例化生成对象后,才能通过对象是属于具体实例的.静态属性def | 定义类方法的关键字,和普通函数作用相同.动态属性self | 类方法必须有的参数,代表的是实例自身class_var | 类变量,可以在外部直接调用,不需要先进行实例话 2, 实例化,在python中使用类似函数调用的方式实例化类,并没有其它语言中的特殊关键字 12t1 = Test()#t1 就是类Test的具体对象 3, 访问属性,同样是上例子 123456789101112131415161718class Test(object): class_var = &apos;class_var&apos; def obj_func(self): obj_var = &apos;obj_var&apos; print(obj_var)t1 = Test()Test.class_var = &apos;modify from Test&apos;print(Test.class_var)#print(Test.obj_func())t1.class_var = &apos;modify from t1&apos;print(&apos;Test:&apos;,Test.class_var)print(t1.class_var)print(t1.obj_func())#print(t1.obj_var) 我们可以发现几个情况: (1)类变量不需要实例化可以访问,实例在实例化后会共用类变量, (2)不能通过实例修改类变量,修改的自身的那份类变量.相当于新生成了一个实例变量. (3)类里定义的方法通常没有实例化,是不能访问. (4)类方法里定义的实例变量是不能在外部直接调用的. 4, 类的内置方法,可以查看一些类的基本信息.(有些属性实例不能使用.) 1234567891011121314151617__init__ | 构造方法__del__ | 析构函数__name__ | 查看类名__dict__ | 查看类属性成员 __doc__ | 查看类文档__class__ | 查看对象所属的类__module__ | 查看对象所在模块__bases__ | 查看基类__mro__ | 查看继承顺序__call__ | 让实例化的对象可调用(即可以加执行符号())__str__ | 打印对象是,返回这个方法的值,通常用在实例化的对象定制信息__getitem__ | 见第9小点__setitem__ | 见第9小点__delitem__ | 见第9小点__new__ | 实例化方法__slots__ | 限制类属性__metaclass__ | 查看元类 5, 构造函数,类的实例化时执行的函数,通常用来实现对象的初始化.__init___ 1234567891011121314151617181920class Test(): name = &apos;class_var&apos; def __init__(self,name,choice=None): self.name = name self.choice = choice if self.choice == &apos;yes&apos;: self.say_hello() else: self.other() def say_hello(self): print(&apos;Welcome,%s&apos;%self.name) def other(self): print(&apos;No choice&apos;)t1 = Test(&apos;sylar&apos;,&apos;yes&apos;)print(t1.name)#Test.namet2 = Test(&apos;tom&apos;) 通过这个例子可以发现,构造函数中定义的属性是针对实例本身,并且也印证了类中的关键字self是指对象而不是类 6, 析构函数,__del__()也是可选的，如果不提供，则Python 会在后台提供默认析构函数.在对象销毁时自动执行的函数,显示的执行可以使用del obj 1234567891011121314import timeclass del_test(object): def say_bye(self): print(&apos;see you next time&apos;) def __del__(self): self.say_bye()o1 = del_test()del o1time.sleep(3)o2 = del_test() 7, 私有属性,无法在外部调用,但是可以在内部调用,从而隐藏某些属性或方法. 1234567891011class Test(object): def __init__(self,name,id_status): self.name = name self.__status = id_status def show_status(self): print(self.__status)t1 = Test(&apos;sylar&apos;,&apos;some info&apos;)t1.show_status()t1.__status 单下划线、双下划线、头尾双下划线说明： foo: 定义的是特殊方法,一般是系统定义名字,类似 init() 之类的. _foo: 以单下划线开头的表示的是 protected 类型的变量,即保护类型只能允许其本身与子类进行访问,不能用于 from module import * __foo: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了. 8, call方法,让不可执行的对象变的可执行 1234567class Animal(object): def __call__(self, *args, **kwargs): print(&apos;call func&apos;)t = Animal()t()Animal()() 9, __getitem__,__setitem__,__delitem__.用类模拟类似字典的操作 1234567891011class Test(object): def __getitem__(self,key): print(&apos;__getitem__:&apos;,key) def __setitem__(self, key, value): print(&apos;__setitem__:&apos;,key,value) def __delitem__(self, key): print(&apos;__delitem__:&apos;,key)t1 = Test()t1[&apos;name&apos;]t1[&apos;name&apos;] = &apos;sylar&apos;del t1[&apos;name&apos;] 类的继承1, 继承,代码重用,派生类(子类)会完全继承基类(父类)的所有属性. 1234567891011121314class Base_Class(object): def __init__(self,name): self.name = name self.say_hi() def say_hi(self): print(&apos;Welcome, %s!&apos;%self.name) def call_me(self): print(&quot;%s&quot;%self.name)class Sub_Class(Base_Class): passt1 = Sub_Class(&apos;sylar&apos;)t1.call_me() 2, 方法重写: 当子类中定义的属性或方法和父类重名时,子类会覆盖父类中的定义.有些时候需要父类的方法,又需要做一些改动.可以直接在子类中调用父类的方法然后再添加新的代码,或者使用super函数.(建议使用super) 123456789101112131415class Base_Class(object): def __init__(self,name): self.name = name def call_me(self): print(&quot;%s&quot;%self.name)class Sub_Class(Base_Class): def call_me(self): #super(Sub_Class,self).call_me() Base_Class.call_me(self) print(&apos;modify for Sub_Class&apos;)t1 = Sub_Class(&apos;sylar&apos;)t1.call_me() 3, 多继承顺序,又分为经典类和新式类,在python3中默认都是使用广度优先. 使用mro方法可以查看继承的查找顺序 12345678910111213141516class Base_A: def __init__(self): print(&apos;from A&apos;)class Base_B(Base_A): passclass Base_C(Base_A): def __init__(self): print(&apos;from C&apos;)class Sub_Class(Base_B,Base_C): passt1 = Sub_Class()print(Sub_Class.__mro__) 这段经典类的代码在python2X 输出为’from A’深度优先,在python3x输出为’from C’广度优先python2 的新式类使用的广度优先 类的多态接口重用,使用统一的接口对子类的方法进行调用 1234567891011121314151617class Animal(object): @staticmethod def run_func(obj): obj.run()class Cat(Animal): def run(self): print(&apos;Cat is running&apos;)class Mouse(Animal): def run(self): print(&apos;Mouse is running&apos;)c1 = Cat()m1 = Mouse()Animal.run_func(c1)Animal.run_func(m1) 类内置装饰器1, 静态方法 staticmethod不能访问类和实例属性,相当于和类本身没有什么关系,只是需要通过类名来调用这个方法.而且实例化后self也不会被传入到这个方法中.前面的多态就是一种使用场景. 2, 类方法 classmethod只能访问类变量不能访问实例变量 1234567891011class Animal(object): name = &apos;Tom&apos; def __init__(self): self.name = &apos;Jerry&apos; @classmethod def run_func(self): print(&apos;%s is running&apos;%self.name)t = Animal()t.run_func() 3, 属性方法 把一个方法当作静态属性来使用 单独使用,不能传参数 12345678910class Animal(object): def __init__(self): self.name = &apos;Jerry&apos; @property def run_func(self): print(&apos;%s is running&apos;%self.name)t = Animal()t.run_func 配合setter接受赋值,实现类似传入参数的功能 123456789101112class Animal(object): def __init__(self): self.__who = None @property def run_func(self): print(&apos;%s is running&apos;%self.__who) @run_func.setter def run_func(self,who): #print(&apos;set to name&apos;,who) self.__who = who 配合deleter删除,默认property装饰器转换过来的属性是不能删除的.如果要删除就要使用deleter 1234567891011121314151617181920class Animal(object): def __init__(self): self.__who = None @property def run_func(self): print(&apos;%s is running&apos;%self.__who) @run_func.setter def run_func(self,who): #print(&apos;set to name&apos;,who) self.__who = who @run_func.deleter def run_func(self): del self.__who t = Animal()t.run_func = &apos;Tom&apos;t.run_funcdel t.run_func 类的定制(元类)和type由于python是解释型语言,所以函数和类的定义不是编译时定义的,而是运行时动态创建的.在python中所有的类都是继承object,并由type方法生成的.type接收三个参数:类名,继承的父类元组,需要绑定的函数. 就可以生成一个类 123456789def my_init(self,name): self.name = namedef say_hi(self): print(&apos;Hello %s&apos;%self.name)Test = type(&apos;Test&apos;, (object,), &#123;&apos;say_hi&apos; : say_hi, &apos;__init__&apos; : my_init,&#125;)t = Test(&apos;sylar&apos;)t.say_hi() 1, __new__类的实例化方法,在所有类实例化的时候都是通过new方法 123456789class MyClass(object): def __init__(self): print(&apos;some code in init!&apos;) def __new__(cls, *args, **kwargs): print(&apos;some code in new!&apos;) return object.__new__(cls)t1 = MyClass() new是执行在init之前的,并且通过return触发init的执行 return object.__new__(cls)相当于super去继承但这时候还没生成self, cls相当于self,指代MyClass这个类的自身 2,metaclass元类,创建类的类,类是metaclass创建的实例.在python中自定义类需要先创建metaclass再创建类.python3和python2的语法有所改变 python3 123456789101112131415def my_add(self,value): self.append(value)class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs[&apos;my_add&apos;] = my_add #这里也可以使用lambda return type.__new__(cls, name, bases, attrs)class MyList(list,metaclass=ListMetaclass): pass l1= MyList()l1.my_add(1)l1.my_add(2)print(l1) python2 1234567class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs[&apos;add&apos;] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs)class MyList(list): __metaclass__ = ListMetaclass 属性锁定前面已经说了python类的属性可以动态创建的,为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的slots变量，来限制该class实例能添加的属性 1234567class Test(): #__slots__ = (&apos;name&apos;,&apos;age&apos;) def __init__(self,name,age): self.name = name self.age = aget = Test(&apos;sylar&apos;,18)t.job = &apos;it&apos; 反射判断类或实例是否有相应的属性,简单来说就是通过字符串来操作类. hasattr(obj,name_str),判断对象里是否有对应字符串的属性 12345678910class Test(): #__slots__ = (&apos;name&apos;,&apos;age&apos;) def __init__(self,name,age): self.name = name self.age = aget = Test(&apos;sylar&apos;,18)choice = input()res = hasattr(t,choice)print(res) getattr(obj,name_str),根据字符串获取对象相应的属性或是属性的内存地址 12345678910class Test(): #__slots__ = (&apos;name&apos;,&apos;age&apos;) def __init__(self,name,age): self.name = name self.age = aget = Test(&apos;sylar&apos;,18)choice = input()res = getattr(t,choice)print(res) 12 setattr(obj,name_str,attrs),根据字符串给对象设置相应的属性 1234567891011class Test(): #__slots__ = (&apos;name&apos;,&apos;age&apos;) def __init__(self,name,age): self.name = name self.age = aget = Test(&apos;sylar&apos;,18)choice = input()setattr(t,choice,&apos;Tom&apos;)v = getattr(t,choice)print(t.name,v) delattr(obj,name_str),删除字符串对应的属性 12345678910class Test(): #__slots__ = (&apos;name&apos;,&apos;age&apos;) def __init__(self,name,age): self.name = name self.age = aget = Test(&apos;sylar&apos;,18)choice = input()delattr(t,choice)print(t.name)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(十)]]></title>
    <url>%2F2014%2F12%2F08%2Fpython%E5%9F%BA%E7%A1%80(%E5%8D%81)%2F</url>
    <content type="text"><![CDATA[模块模块的定义模块就是从逻辑上组织的python代码,是.py的python文件.将python文件的目录和目录下各个文件当作模块对象来处理(用import关键字引用,成为当前代码的一部分),而不是作为一般的文件对象来处理(例如通过open来作为单纯的字符串数据).同时分为module模块和package包两个概念,module是文件对象对应的文件,package是路径对象(一个文件夹),对应导入的是文件夹中的init.py 模块分为三类: 1,标准库:python解释器内置的基础模块,python官方收录维护的代码.2,开源模块: 由第三方组织提供的代码3,自定义模块: 开发者自己编写维护的代码都称为自定义模块 导入方法通常我们可以直接使用import module_name来导入一个模块.同时我们也可以使用from … import …来导入模块中的部分代码. 1, import module_name将一个py文件作为模块引入当前代码,通常用来导入内置或者是已经安装过的第三方模块.(会导入整个.py文件)1234#module_test/test1.pyname = &apos;test1&apos;def run_hello(): print(&apos;hello world&apos;) 1234#module_test/test2.pyimport test1test1.run_hello()print(test1.name) 2, from package import module_name从一个package中引入py模块(会优先初始化路径下的init.py).通常用来导入自定义模块.(会导入整个.py文件)1234#module_test/test1.pyname = &apos;test1&apos;def run_hello(): print(&apos;hello world&apos;) 1234#module_test/test2.pyfrom module_test import test1test1.run_hello()print(test1.name) 3, from package.module_name import fun_name从具体模块中引入指定的代码块,通常封装为函数或者是类1234567#module_test/test1.pyname = &apos;test1&apos;def run_hello(): print(&apos;hello world&apos;)def run_test1(): print(&apos;in the test1&apos;) 1234#module_test/test2.pyfrom module_test.test1 import run_hellorun_hello()print(locals()) 4, from package.module_name import *类似于from package import module_name的引用方法,但是呢有一个坏处因为不是用module_name来引用模块中的代码,而是直接在当前代码块中引用对象.所以会被当前代码块中的同名对象覆盖. 1234567#module_test/test1.pyname = &apos;test1&apos;def run_hello(): print(&apos;hello world&apos;)def running_test(): print(&apos;in the test1&apos;) 12345678#module_test/test2.pyfrom module_test.test1 import *running_test()print(locals())def running_test(): print(&apos;in the test2&apos;)running_test() 5, from package import module_name as alias_name / from package.module_name import fun_name as alias_name使用as关键字给引入的代码块使用一个别名 123456789#module_test/test2.pyfrom module_test import test1 as mytestprint(locals())def running_test(): print(&apos;in the test2&apos;)running_test()mytest.running_test() or123456789#module_test/test2.pyfrom module_test.test1 import running_test as mytestprint(locals())def running_test(): print(&apos;in the test2&apos;)running_test()mytest() 6, 修改init.py 在导入包的时候,由于我们执行的是包的init.py所以需要在这个文件中对module进行一些定义 直接导入包会提示找不到模块1234567#module_test/test1.pyname = &apos;test1&apos;def run_hello(): print(&apos;hello world&apos;)def running_test(): print(&apos;in the test1&apos;) 1234#module_test/test2.py import module_testmodule_test.test1.running_test() 修改init_.py 这一步相当于给包下的模块做索引. 1234567#module_test/test1.pyname = &apos;test1&apos;def run_hello(): print(&apos;hello world&apos;)def running_test(): print(&apos;in the test1&apos;) 12#module_test/__init__.pyfrom . import test1 123456#module_test/test2.py import module_testimport module_testmodule_test.test1.running_test() import 本质import的过程简单来说分为三步: 1,根据package,module_name搜索环境变量的路径中是否有module同名的文件,当前路径和sys.path. 2,将搜索到的同名文件或是文件中指定部分代码块载入内存. 3,根据是否使用as判断,默认内存中加载的代码块赋值给module_name或是fun_name.如果使用了as将内存中的代码块赋值给as给出的变量名. python标准库官方文档点击 timetime模块主要是对时间的一些输出格式处理,需要了解unix时间戳(timestamp)和时区等相关概念.time模块中时间是默认以一个元组的方式存储(python称为struct_time) asctime 将时间元组返回为一个英语系标准时间格式输出 1print(time.asctime()) clock 进程所用cpu时间 ctime 将unix时间戳转换为英系标准格式时间, 默认当前时间 1print(time.ctime(987654321)) gmtime 将一个时间戳返回一个时间信息的元组,默认当前时间 1print(time.gmtime(987654321)) localtime() 将当前时区的unix时间戳返回为一个时间元组的格式,默认当前时间 1print(time.localtime(987654321)) mktime 将时间元组以时间戳方式返回 12a = time.gmtime()print(time.mktime(a)) process_time 用于分析的进程时间：内核和用户空间CPU时间之和。 1print(time.process_time()) sleep 执行指定秒数的延迟 1print(time.sleep(3)) strftime 将一个时间元组返回为一个指定格式的字符模式 12a = time.gmtime()print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,a)) strptime strftime的反操作,格式要一致 123a = time.gmtime()b = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,a)print(time.strptime(b,&quot;%Y-%m-%d %H:%M:%S&quot;)) time 以浮点数的方式返回当前时间 补充记住3种时间格式转换方式 datetimetime模块的增强功能, 有date,datetime,time,timedelta,tzinfo,timezone几个子模块 datetime.now 当前时间 1print(datetime.datetime.now()) timedelta 对时间进行数学运算 1234print(datetime.datetime.now()+datetime.timedelta(-10))print(datetime.datetime.now()+datetime.timedelta(hours=-10))print(datetime.datetime.now()+datetime.timedelta(minutes=-10))print(datetime.datetime.now()+datetime.timedelta(seconds=-10)) os对操作系统进行调用的接口, 1234567891011121314151617os.getcwd() | 获取当前工作目录os.chdir() | 移动工作目录os.pardir() | 获取当前父目录os.makedirs() | 递归生成多级目录os.removedirs() | 删除多级目录os.mkdir() | 生成单级目录os.rmdir() | 删除单级目录os.listdir() | 列出指定目录下文件和子目录,相当于ls -aos.remove() | 删除文件os.rename() | 重命名文件或目录os.stat() | 文件信息os.sep | 操作系统的路径分隔符,x = os.sep.encode()os.linesep | 查看换行符 x = os.linesep.encode()os.pathsep | 多个文件路径字符串之间分隔符os.name | 操作系统类别,win为nt,linux为posixos.system() | 执行一个操作系统允许执行的命令:os.system(&apos;pwd&apos;)os.environ() | 系统环境变量 用的比较多的是路径查询 abspath 输出文件绝对路径 1print(os.path.abspath(__file__)) dirname 返回路径 1print(os.path.dirname(__file__)) 123456789os.path.split() | 返回分割目录和文件名的元组os.path.basename() | 返回文件名os.path.exists() | 判断文件是否存在,返回True或者Falseos.path.isabs() | 判断绝对路径os.path.isdir() | 判断目录os.path.isfile() | 判断是否为文件os.path.join() | 组合多个路径os.path.getatime() | 返回文件atime,相应还有ctime,mtimeos.path.getsize() | 获取文件大小 补充: 字符串前加r申明字符串不需要转义,例如’\‘符号,通常用在正则和文件地址目录等字符串前加u申明字符串编码为unicode,通常用在申明非英文字符串编码字符串前加b申明字符串为bytes类型,python2中没有意义只是为兼容python3的写法:b’str’ == bytes(‘str’,encoding=’utf8’) syspython解释器相关操作 官方文档点击 常用的两个 sys.argv 获取python执行时的参数,默认为列表,第一个值为文件名 sys.exit 退出python解释器.终止程序的运行 123456789sys.getdefaultencoding() | 获取解释器默认编码sys.path | 获取解释器默认环境变量path中的路径sys.platform | 获取解释器的操作系统sys.api_version | 获取解释器的c的api版本sys.base_exec_prefix | 解释器执行程序所在目录sys.builtin_module_names | 内置模块sys.exc_info() | 获取当前进程的信息,此外还有exc_traceback,exc_value等sys.modules | 解释器中已导入的模块信息sys.stderr | 标准错误对象信息,此外还有stdin,stdout stdin,stdout,std.err 1sys.stdout.write(&apos;please&apos;) 12x = sys.stdin.readline()print(x) random random 取0-1之间的浮点数,uniform方法可以指定范围 123import randomprint(random.random())print(random.uniform(1,10)) 随机取两个整数之间的值 1print(random.randint(1,100)) #取值范围包含1和100 随机取两个整数之间的值 1print(random.randrange(0,100)) #取值范围包含0,不包含100 随机取一个序列(列表,元组,字符串)中的一个值, 12list_test = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]print(random.choice(list_test)) #choice方法返回值是字符,choices返回值是一个列表 随机去一个序列中的多个值 12list_test = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]print(random.sample(list_test,3)) 随机打乱序列顺序 123list_test = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]random.shuffle(list_test)print(list_test) 验证码程序1234567891011def check_code(): import random checkcode=&apos;&apos; for i in range(6): #6位验证码位置循环 current = random.randrange(0,6) #随机字母和数字的条件码 if current == i : #如果位置码和条件码一致生成字母 tmp = chr(random.randint(65,90)) else: #负责生成0-9数字 tmp = random.randint(0,9) checkcode += str(tmp) return checkcode shutil对内置函数open更高级的扩展,处理文件对象操作,复制,压缩 copyfileobj 复制文件对象 123f1 = open(&apos;a.txt&apos;,&apos;rb&apos;)f2 = open(&apos;b.txt&apos;,&apos;wb&apos;)shutil.copyfileobj(f1,f2) copyfile 复制文件,调用的copyfileobj方法 1shutil.copyfile(&apos;a.txt&apos;,&apos;c.txt&apos;) copy 复制文件调用copyfile和copymode,复制文件和权限 copy2 复制文件调用copyfile和copystat,复制文件和信息 1shutil.copy(&apos;a.txt&apos;,&apos;d.txt&apos;) move 重命名 1shutil.move(&apos;a.txt&apos;,&apos;e.txt&apos;) chown 修改属主 1shutil.chown(&apos;a.txt&apos;,user=&apos;sylar&apos;,group=&apos;sylar&apos;) make_archive 压缩,调用的ZipFile 和TarFile两个模块 1shutil.make_archive(&apos;test&apos;,&apos;tar&apos;,root_dir=&apos;./&apos;) 1234import tarfilet = tarfile.open(&apos;test.tar&apos;,&apos;r&apos;)t.extractall()t.close() 123456copymode | 复制文件权限copystat | 复制文件信息copytree | 复制目录树rmtree | 删除目录树disk_usage() | 获取磁盘空间get_terminal_size() | 终端大小, json 和pickle模块 shelve1, json和pickle 因为在网络传输中,python3是默认是用bytes类型传输数据,而在文件中是使用str类型来保存数据,所以数据需要在bytes和str类型中进行转换.json是可跨语言使用的数据交互或序列化的数据标准,pickle是python自有的数据交互和序列化的数据标准.这两个模块的功能: dump load 对数据进行处理并写如文件 12345678d1 = &#123;&apos;name&apos;:&apos;sylar&apos;, &apos;age&apos;:18,&#125;with open(&apos;test.txt&apos;,&apos;wb&apos;) as f1: pickle.dump(d1,f1)with open(&apos;test.txt&apos;,&apos;rb&apos;) as f2: data = pickle.load(f2) print(data) dumps loads 只对数据进行处理 1234567d1 = &#123;&apos;name&apos;:&apos;sylar&apos;, &apos;age&apos;:18,&#125;print(type(d1))dump_obj = pickle.dumps(d1)print(type(dump_obj))load_obj = pickle.loads(dump_obj)print(type(load_obj)) 2, shelve模块pickle对一个文件无论dumps多次只能loads一次,如果需要记录文件的多次dumps可以使用shelve模块.使用方法和open差不多 写 12345d1 = &#123;&apos;name&apos;:&apos;sylar&apos;, &apos;age&apos;:18,&#125;with shelve.open(&apos;test.shelve&apos;) as f: f[&apos;key&apos;] = d1 读 123with shelve.open(&apos;test.shelve&apos;) as f: for k,v in f.items(): print(k,v) 3, 其它文档处理xml,pyyaml,confgparser hashlib,hmac用于加密相关的操作,python3里面hashlib整合了md5和sha模块.hmac多重加密 12345678import hashlibtext = b&apos;hello,world&apos;t1 = hashlib.md5(text)t = hashlib.md5()t.update(text)print(&apos;二进制:&apos;,t.digest())print(&apos;16进制:&apos;,t.hexdigest())print(&apos;16进制:&apos;,t1.hexdigest()) 123456import hmactext = &apos;abcd&apos;.encode(encoding=&apos;utf8&apos;)text_cn = bytes(&apos;我是中文&apos;,encoding=&apos;utf8&apos;)t = hmac.new(text,text_cn)print(&apos;二进制:&apos;,t.digest())print(&apos;16进制:&apos;,t.hexdigest()) re正则表达式1,特殊匹配模式 123re.I | re.IGNORECASE 启用后不区分大小写re.M | re.MULTILINE 启用后匹配行首和行尾,不启用以字符串计算起始和结束位置re.S | re.DOTALL 启用后不忽略换行符 2, 正则表达式匹配符: 123456789101112131415161718192021. | 默认匹配\n之外任意一个字符,指定flag DOTALL 则可以匹配换行符^ | 定位至字符串起始位置.指定flag MULTILINE,则定位行首$ | 定位至字符串结束位置.指定flag MULTILINE,则定位行尾* | 匹配*号前字符任意次+ | 匹配前一个字符多次? | 匹配前一个字符最多1次&#123;m&#125; | 匹配前一个条件m次&#123;n,m&#125; | 匹配前一个条件n到m次| | 匹配左右条件() | 配合&#123;m&#125;等使用组成一个条件[a-z] | 匹配指定范围小写字母[A-Z] | 匹配指定范围大写字母[0-9] | 匹配指定范围数字\A | 从字符起始位置匹配 同^\Z | 匹配字符结束 同$\d | 匹配数字\D | 非数字\w | 匹配[0-9a-zA-Z]数字和字母\W | 非数字和字母,即特殊符号\s | 匹配空白字符,换行等 \t, \n, \r(?P&lt;name&gt;) | 分组匹配,将结果以name为key存储为字典 3, 常用方法 re.match() 从字符串起始位置开始匹配,也就是说默认是带了^,下面第二例子就不能匹配 12345import retext = &apos;abcdddddcba0022abc&apos;res = re.match(&apos;a.+\d&apos;,text)print(res.group()) 1res = re.match(&apos;cba\d+&apos;,text) re.search() 在整个字符串中匹配一次 上面错误的例子就可以使用search进行匹配 12res = re.search(&apos;cba\d+&apos;,text)print(res.group()) re.findall 匹配字符串中所有符合条件的字符,不需要group方法来返回输出 123#res = re.findall(&apos;[a-z]&#123;3&#125;&apos;,text) 这两种结果是不一致的.res = re.findall(&apos;[a-z]&#123;1,3&#125;&apos;,text)print(res) split() 按照匹配规则分割字符串 12res = re.split(&apos;c&apos;,text)print(res) sub() 替换 12res = re.sub(&apos;c&apos;,&apos;_&apos;,text,count=2)print(res) groupdict和分组匹配 1234id_card = &apos;510703200004010517&apos;id_info = re.search(&quot;(?P&lt;city&gt;[0-9]&#123;6&#125;)(?P&lt;birth_year&gt;[0-9]&#123;4&#125;)(?P&lt;birth_day&gt;[0-9]&#123;4&#125;)&quot;,id_card).groupdict()print(id_info)#返回结果为:&#123;&apos;city&apos;: &apos;510703&apos;, &apos;birth_year&apos;: &apos;2000&apos;, &apos;birth_day&apos;: &apos;0401&apos;&#125; 匹配从某个字符开始,但是不包含这个字符 1234test = &apos;xxx.html&apos;re.search(&apos;((?!\.).)*$&apos;,test)#普通匹配((?!x).)*$,x为要过滤的字符,]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(九)]]></title>
    <url>%2F2014%2F12%2F03%2Fpython%E5%9F%BA%E7%A1%80(%E4%B9%9D)%2F</url>
    <content type="text"><![CDATA[内置函数python在解释器内部为我们编写好的函数,可以直接使用.官方文档 abs(): 返回一个数字的绝对值。参数可以是整数或浮点数。如果参数是一个复数，则返回它的大小。 1abs(-200) all():如果可迭代对象所有的元素都是真个返回True（如果是空返回False). 12list = [1,-1,65,5,4,22,8,6] #非0即为真all(list) any():如果可迭代对象任意元素是假返回True,（如果是空返回False) 12list = [0,-1,65,5,4,22,8,6]any(list) ascii():把一个数据对象变为字符串形式 12text = ascii(list)print(text,type(text)) bin():将一个整数转换为二进制数值(快速计算二进制) 12print(bin(10))print(bin(2)) bool():bool运算函数, bytearray():产生一个bytes类型的数组,让数据达到可以修改的目的 123a = bytearray(&apos;abcde&apos;,encoding=&apos;utf8&apos;)a[3] = 67 #bytes类型是在ascii码表中对应表示的字符print(a) bytes():python3的新的数据类型,是ascii码形式表示,以b’xxx’的方式打印,和str字符类型都是不可以修改的. callable(): 判断一个函数中是否可以调用.(即可不可加’()来执行’) 12345list = []def test_call(): print(&apos;test&apos;)print(callable(list),callable(test_call)) chr(): 把数字对应的ascii码中对应的字符,和ord函数相反 1chr(91) compile():将字符转换为python字节码,python预编译使用. 1234567code = &apos;&apos;&apos;def test_comp(): print(&apos;hello comple&apos;)test_comp()&apos;&apos;&apos;obj = compile(code,&apos;&apos;,&apos;exec&apos;)exec(obj) delattr():配合hasattr,setattr使用,删除一个对象的某个属性. dict():生成字典的函数 dir(): 查看对象能够使用的方法 divmod: 返回两个整数的商和余数 1print(divmod(9,2)) enumerate():对一个可迭代对象进行枚举,一般是有序数据类型. 123a = [1,23,5,7,8,4,90,3,22]for i in enumerate(a): print(i) eval(): 将字符串转换为数学表达式 1eval(&apos;1+1&apos;) exec():将字符串当作代码执行 1exec(&apos;for i in range(10):print(i)&apos;) filter() 根据条件过滤一个可迭代对象,filter返回一个迭代器 1234l1 = [566,55,5,7,8,4,90,3,22]res = filter(lambda n: n &gt; 40,l1)for i in res: print(i) float() 将字符串编程浮点数 1float(&apos;+1.23&apos;) format()将数字转换为字符类型 12a = format([22,33])print(a,type(a)) frozenset 将集合变味不可变的. getattr() 获取一个对象的属性 globals() 返回当前全局属性 hasattr() 判断一个对象是否有一个属性 hash() 1print(hash(&apos;slkfjkl&apos;)) help() 对象的帮助信息 hex() 返回十进制对应16进制值 id() 返回对象在python解释器中的唯一标识符(简单理解就是内存地址,不过这个内存地址是python解释器管理的) input() 获取用户输入 int() 将对象转换为整数 1int(66.22) isinstance() 判断是否属于某种数据类型 1print(isinstance(a,str)) issubclass() 用于判断是否包含子类的关系 iter() 将一个可迭代对象转换为迭代器 len() 返回对象的长度或者是元素总数 12len([1111,22222,33333,44444])len(&apos;abcde&apos;) list() 生成列表的方法 locals 返回局部属性,一般是函数或者类的实例里面使用 map() 对可迭代对象根据条件返回一个结果的迭代器,和filter函数功能类似. 12345l1 = [566,55,5,7,8,4,90,3,22]res = map(lambda n: n*2,l1)#res = map(lambda n:n&gt;40,l1)for i in res: print(i) max() 判断最大的值 1234max(2,3,4,5,6,22,11)l1 = [566,55,5,7,8,4,90,3,22]print(max(l1)) memoryview() min() 和max方法相反 next() 迭代器的next方法 oct() 返回十进制数字对应的8进制值 123oct(7)oct(8)oct(16) open() 文件操作 ord() 返回字符在ascii码中的数值代码 1ord(&apos;a&apos;) pow() 乘方运算 12pow(2,3)pow(3,2) print() 标准打印输出 property() 给一个对象增加属性 range() 生成一个序列 repr() 返回包含对象的可打印表示的字符串。 reversed 对一个有序迭代器进行反排序 123l1 = [566,55,5,7,8,4,90,3,22]for i in reversed(l1): print(i) round() 处理小数点后的精度 1round(10.22333455,5) set() 集合 slice切片操作 12l1 = [566,55,5,7,8,4,90,3,22]print(l1[slice(2,5)]) sorted() 排序 12345a = &#123;-1:7,3:77,22:777,33:666&#125;print(sorted(a.items()))print(sorted(a.items(),key=lambda x:x[1]))l1 = [566,55,5,7,8,4,90,3,22]print(sorted(l1)) str() 字符串 sum() 加法运算 123l1 = [566,55,5,7,8,4,90,3,22]a = &#123;-1:7,3:77,22:&apos;abc&apos;,33:&apos;vdf&apos;&#125;print(sum(l1)) super() 在类中对父类进行继承的函数 tuple() 元组 type() 判断对象类型 vars() 返回一个模块，类实例的dict属性，或与任何其他对象dict属性。 zip() 组合两个可迭代对象,返回一个迭代器 1234a = &apos;abcde&apos;b = [1,2,3,4,5]zip(a,b)for i in zip(a,b):print(i) import() 将字符串当模块名导入,类似import]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(八)]]></title>
    <url>%2F2014%2F12%2F01%2Fpython%E5%9F%BA%E7%A1%80(%E5%85%AB)%2F</url>
    <content type="text"><![CDATA[生成器在函数中使用yield关键字就会将一个普通的函数变成一个生成器(generator),普通的函数只能使用return来退出函数,而不执行return之后的代码.而生成器可以使用调用一个next方法来返回生成器中上一次yield时候的状态.并且可以使用send方法给yield重新赋值.这样就可以灵活的进入和跳出函数.因此在程序中生成器可以中断当前函数,去执行其它的代码,在合适的时候跳回函数继续执行 1234567891011121314151617181920212223242526def yield_test(): print(&apos;befor the first&apos;) first = yield print(first) print(&apos;before the second&apos;) second = yield print(second) print(&apos;before the Third&apos;) Third = yield &apos;也可以有返回值&apos; print(Third) print(&apos;after the Third&apos;) #next方法g = yield_test()g.__next__()g.__next__()yield_text = g.__next__() #获取yield传出的数据,接受数据next和发送数据yield的位置顺序相同print(yield_text)# g.__next__()#send方法g = yield_test()g.__next__() #做实验时第一次必须是next,send会报错g.send(&apos;2222&apos;) #send发送的数据会被赋值给当前yield之前的代码中生效. #简单说是赋值给前一个yield以便本次代码执行g.send(&apos;3333&apos;) 补充:通过这个例子我们发现1,send方法被生成器当作了一次next,并且send的值会复制给上一个yield,2,yield和__next_方法是一一对应.当next比函数内yield多时,最后一个next会报一个StopIteration异常.3,yield后的代码会在下一次next调用时才会执行.4,yield可以发送数据,也可以接受数据.获取数据时要注意传入和传出不同时机才能获取正确的yield值 所以我们通常把生成器用在可循环的对象1234567891011def read_file(): read_size = 10 with open(&apos;test.txt&apos;,&apos;rb&apos;) as f: while True: text = f.read(read_size) yield text #通过yield获取当前的text值g = read_file() while True: print(g.__next__())#生成器这样使用会进入一个死循环 补充:5, 生成器必须要有明确的退出条件,为了不造成死循环. 所以慎用循环.12345678910111213def read_file(): read_size = 10 with open(&apos;test.txt&apos;,&apos;rb&apos;) as f: while True: text = f.read(read_size) if text: #判断文件是否读取完毕 yield text else: returng = read_file() while True: print(g.__next__()) 迭代器iterable(可迭代对象)可以直接作用与for循环的对象.可迭代对象分为:一,集合数据类型如:str字符串,list列表,dict字典,tuple元组,set集合等.二,生成器generator和带yield的函数.判断是否为iterable对象可以使用函数isinstance().在python中list等集合数据类型是非常占用内存的,通过使用iter()可以将一个可迭代对象变成一个迭代器.迭代器中不存储具体数据,只是保存了产生这种数据的逻辑对象.在使用时才产生需要的数据,可以大大节省空间. 12345678910from collections import Iteratorlist = []for i in range(10): list.append(i)print(list,isinstance(list,Iterator))list_Iterator= iter(list)print(list_Iterator,isinstance(list_Iterator,Iterator))for i in list_Iterator: print(i) 补充:1, 迭代器中并没有保存真正的数据,只有在我们去通过next方法去迭代器中取数据2, 迭代器中是按照一定的顺序输出所有数据,不能取指定的数据. 装饰器装饰器(decorator)是一种函数的高级用法,主要是通过高阶函数和返回函数组合的方式,修饰其它函数.达到被修饰的函数代码不用修改,调用方式也不变的目的.主要作用就是给被修饰的函数添加功能. 原函数不带参数 12345678910#假如有这么三个函数,我们需要记录访问时间和函数名,但是又不能修改函数def home(): print(&apos;index page&apos;)def bbs(): print(&apos;bbs page&apos;)def news(): print(&apos;news page&apos;)home()bbs()news() 1234567891011121314151617181920212223242526272829#加上装饰器后的效果import timelog_list = []def user_log(func): #将被装饰函数作为参数传入user_log这个装饰器 def wrapper(): #触发执行装饰器的函数 func() #在装饰器内执行原函数 log_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) #装饰器内具体新代码 page_name = func.__name__ log_page = str(log_time+&apos; -&gt;&apos;+page_name) log_list.append(log_page) return wrapper #将触发函数返回,一定不要加()执行符号@user_logdef home(): print(&apos;index page&apos;)@user_logdef bbs(): print(&apos;bbs page&apos;)@user_logdef news(): print(&apos;news page&apos;)home()bbs()news()print(log_list) 带参数的函数 12345678910111213141516计算函数运行时间的装饰器import timedef time_consum(func): def wrapper(*args,**kwargs): start_time = time.time() func(*args,**kwargs) print(&apos;running&apos;,time.time()-start_time) return wrapper@time_consumdef user_profile(username): time.sleep(3) print(&apos;welcome %s&apos;%username)user_profile(&apos;sylar&apos;) 装饰器带参数, 1234567891011121314151617181920212223242526272829303132#根据装饰器参数执行不同的功能import timelog_list = []def change_type(ch_type=&apos;other&apos;): def decorator(func): def wrapper(*args,**kwargs): if ch_type == &apos;tc&apos;: start_time = time.time() func(*args,**kwargs) print(&apos;running&apos;,time.time()-start_time) else: func() print(&apos;other type code&apos;) log_time = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) # 装饰器内具体新代码 page_name = func.__name__ log_page = str(log_time + &apos; -&gt;&apos; + page_name) log_list.append(log_page) return wrapper return decorator@change_type()def home(): print(&apos;index page&apos;)@change_type(&apos;tc&apos;)def user_profile(username): time.sleep(3) print(&apos;welcome %s&apos;%username)home()user_profile(&apos;sylar&apos;)print(log_list) 递归函数在函数内部,调用了这个函数自己.就叫做递归函数 12345678#直接使用递归法求解斐波那契数量的第num个数字def fib(num): if num&lt;2: return num return fib(num-1)+fib(num-2)for i in range(10): print(fib(i)) 补充递归函数必须要有一个明确的结束条件,python中支持最大递归次数1000]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(七)]]></title>
    <url>%2F2014%2F11%2F27%2Fpython%E5%9F%BA%E7%A1%80(%E4%B8%83)%2F</url>
    <content type="text"><![CDATA[Function 函数基础函数是一段组织好的能够实现特定功能或者逻辑的代码块,函数代码在文件执行时读入内存并不执行,在调用函数时执行,简单来说是把一段代码封装给一个函数名(可以用变量的概念去理解,即把一段代码赋值给一个函数名),当使用函数名加执行标记时才运行这段内存中的代码.函数的作用可以减少重复代码,在不同的地方要使用相同的代码块,我们就可以把这段代码封装成函数.同时当多处相同的代码需要修改时,只需要修改函数定义时一处即可扩展性好. 123456789#定义函数def func_name(parameters): name = parameters print(&apos;exec code with %s&apos; %name) return &apos;some code&apos;#函数的调用func_name(&apos;sylar&apos;)a = func_name()print(a) ###参数函数在定义和调用的时候是可以传入参数,在定义时申明的参数称为形参,在函数调用时传入的参数称为实参.一般来说形参只在函数内生效,但是当传入的是list(列表),dict(字典),func(函数)由于这些复杂数据类型传入是对象的内存地址,所以在函数内做了修改,在函数外也会产生响应的修改.因此参数可以分为可变参数和不可变参数.但我们通常在使用中一般将函数的参数使用传入的方式来分类: 位置参数根据定义函数时的形参位置一一对应的传入参数,形参和实参顺序必须一致. 123456def fun1(name, age, post): print(&apos;My name is %s&apos; % name) print(&apos;At the age of %s&apos; % age) print(&apos;The position is %s&apos; % post) fun1(&apos;sylar&apos;,18,&apos;IT&apos;) 关键字参数使用形参的关键字确定传入实参的值,此时不需要关注参数的顺序 1234567def fun1(name, age, post): print(&apos;My name is %s&apos; % name) print(&apos;At the age of %s&apos; % age) print(&apos;The position is %s&apos; % post)fun1(name=&apos;sylar&apos;,post=&apos;IT&apos;,age=18,)fun1(&apos;tom&apos;,post=&apos;IT&apos;,age=19,) 关键字参数和位置参数的方式可以混用,但是记住不能在关键字参数前传入位置参数 12#错误的调用fun1(name=&apos;sylar&apos;,age=18,&apos;IT&apos;) 默认参数在定义形参的时候,给参数设置一个默认值.在调用函数时不传入这个参数就使用默认值. 123456def fun1(name, age, post=&apos;IT&apos;): print(&apos;My name is %s&apos; % name) print(&apos;At the age of %s&apos; % age) print(&apos;The position is %s&apos; % post)fun1(name=&apos;sylar&apos;,age=18) 默认参数也可以和其它参数混搭使用,但是默认参数只能定义在所有参数的尾部.传入参数的时候只需要遵循放在位置参数之后传入 12#错误的定义def fun1(post=&apos;IT&apos;,name, age): 不定长参数在定义一个函数时,会出现我们并不知道我们使用函数时会传入多少个参数的情况,这时候就可以使用不定长参数.使用*args和**kwargs 12345678#*args会将收到的参数组合为一个元组def fun1(name,age,*args,): print(&apos;My name is %s&apos; % name) print(&apos;At the age of %s&apos; % age) print(args) hope_list= &apos;,&apos;.join(args) print(&apos;He hopes list is:%s&apos;%hope_list)fun1(&apos;sylar&apos;,18,&apos;IT&apos;,&apos;travel&apos;,&apos;movie&apos;) 12345678#kwargs会将传入的参数组合为字典,在函数内调用需要函数内代码去获取字典的key才可以取到对应的值def fun2(**kwargs): print(kwargs) name = kwargs[&apos;name&apos;] age = kwargs[&apos;age&apos;] print(&apos;My name is %s&apos; % name) print(&apos;At the age of %s&apos; % age)fun2(name=&apos;sylar&apos;,age=18) 局部变量和全局变量首先需要理解名称空间和作用域,名称空间是指对某段代码进行命名的操作,例如变量名,函数名.全局变量是在整个文件顶部定义,对整个文件都生效.局部变量是相对而论的,我们先来看一个例子(这几个概念,我也不能很好的阐述) 12345678910111213g_var = &apos;this is global var&apos;def foo(): l_var = &apos;in the foo!this is local var&apos; print(g_var) print(l_var)def foo1(): l_var = &apos;in the other foo !this is local var&apos; print(g_var) print(l_var)foo()foo1()print(g_var)print(l_var) 在这个例子中,g_var是在整个代码块中都生效的,那么g_var就是这个代码块的全局变量,而l_var只在函数foo中生效,那么l_var就是foo的局部变量.而在foo1的l_var又是它自己内部定义的局部变量 当局部变量和全局变量同名时,局部变量只在他所属的代码块内生效.并不能影响代码块外的全局变量.同时需要注意的是,局部变量优先. 1234567some_var = &apos;this is global var&apos;print(some_var)def foo(): some_var = &apos;this is local var&apos; print(some_var)foo()print(some_var) 返回值在函数中使用ruturn语句,让函数返回一个结果给函数外的调用.如果没有定义ruturn,函数会返回一个None.当函数执行了return将会跳出函数,不再继续执行函数中的代码 12345#没有ruturn的返回值def foo(): print(&apos;welcome&apos;)a = foo()print(a) 1234567#定义return的返回值和return后的代码不会执行def foo(x,y): z = x + y return z print(&apos;welcome&apos;)a = foo(1,2)print(a) 嵌套函数在函数中嵌套一层函数 1234567def first_func(): print(&apos;in the first&apos;) def second_func(): print(&apos;in the second&apos;) second_func()first_func() second_func() #此时在外面是不能调用嵌套内的函数 补充,使用嵌套函数去试试局部变量能更好的理解局部变量的使用 匿名函数lamba主体通常就是一个表达式,是函数的一个高级用法,在某些特定场景需要使用函数时使用 123456sum = lambda arg1, arg2: print(arg1 + arg2);sum(1,2)def func(arg1,arg2): print(arg1+arg2)func(1,2) 列表生成式:列表生成式表现方式类似于三元运算和匿名函数lambda函数.通过简化代码执行一个教复杂的运算逻辑.这算是函数的一个扩展场景吧 1234567891011121314151617181920#普通代码def func(i): if i &lt; 5: i=i+1 else: i=i*2 return ia = []for i in range(10): num = func(i) a.append(num) #通过列表生成式来完成相同的功能def func(i): if i &lt; 5: i=i+1 else: i=i*2 return ia = [func(i) for i in range(10)] 补充三元运算表达式: 为真时的结果 if 判定条件 else 为假时的结果if 5&gt;3 else 0]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(六)]]></title>
    <url>%2F2014%2F11%2F21%2Fpython%E5%9F%BA%E7%A1%80(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[字典dict使用key来标注value的数据类型,key和value是一一对应的.在字典中key是唯一的,所以字典也是无序的. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#定义一个字典dict = &#123; &apos;name&apos; : &apos;sylar&apos;, &apos;age&apos; : 18, &apos;post&apos; : &apos;OPS&apos;, &apos;salary&apos; : 80000&#125;###常用操作和方法#访问字典的数据,使用定义的key来获取print(dict_test[&apos;name&apos;])#修改字典dict_test[&apos;name&apos;] = &apos;Sylar&apos;print(dict_test[&apos;name&apos;])#copy复制一个字典#clear删除所有元素a = dict_test.copy()print(a)print(a.clear())#fromkyes创建一个新字典，以序列中元素做字典的键，val 为字典所有键对应的初始值a = &#123;&#125;a = a.fromkeys([1,2,3,4,5],&apos;defalt&apos;)print(a)#get获取元素值同dict_test[&apos;name&apos;]print(dict_test.get(&apos;name&apos;))#item遍历所有元素,将元素以键值对元组的方式输出print(dict_test.items())#keys遍历所有元素的valueprint(dict_test.keys())#pop删除一个元素,并返回元素的value值print(dict_test.pop(&apos;age&apos;))print(dict_test)#popitem删除一个元素,并以元组的形式返回key,value值print(dict_test.popitem())print(dict_test)#setdefault设置一个默认值的元素,如果key已经存在则返回对应的valueprint(dict_test.setdefault(&apos;a&apos;,100))print(dict_test)#update用一个字典的数据去更新另外一个字典的数据a = &#123;&apos;name&apos;:&apos;tom&apos;,&apos;a&apos;:&apos;b&apos;&#125;dict_test.update(a)print(dict_test)#valus遍历所有元素的valueprint(dict_test.values())遍历字典的方法for i in dict_test: print(i, dict_test[i])for i in dict_test.items(): print(i)for k,v in dict_test.items(): print(k, v) 文件操作对文件的打开读写是用open函数,打开文件的方式又分为:r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 简单来说常用的:r+先读后写从头开始覆盖写.w+先写后读,默认先创建一个空文件默认也只能追加写在文件最后面(会清空同名文件谨慎使用).a+是追加读写模式,一般情况都用这种模式来操作文件.文件插入数据很麻烦,.所以要修改文件,建议读出一个文件写到一个新文件里,数据替换完成后替换原文件123456789101112131415161718192021222324252627#open函数使用方式,用一个文件句柄的方式去打开一个文件.操作完以后必须关闭文件.f = open(&apos;a.txt&apos;,&apos;r+&apos;,encoding=&apos;utf-8&apos;)a = f.read()f.close()print(a)#常用方法#read读取整个文件,由于是一次性读取整个文件只适合对小文件使用.可以指定参数读取多少个字节a = f.read(1)#close关闭文件#readline每次读取一行#readlines读取整个文件,可以指定参数读取多少行#write写文件#truncate截断一个文件,保留多少个字节#flush手动将内存缓存的数据刷写到硬盘中,而不是等待程序的缓存控制策略去刷写数据#tell返回文件指针的位置#seek移动文件指针的位置f = open(&apos;a.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;)print(f.readline())print(f.readline())print(f.readline())print( f.tell())f.seek(10)print( f.tell())print(f.readline())f.close() with open as f为了更好保护文件,python中提供了with函数来保护对文件的操作.所以我们要进行文件操作一定要使用with函数.在python3中with支持同时操作多个文件 123456#因为读取文件是按行读取所以for line in f:,而不是使用for i in readline:.后一种方法是读取每一行的字符串的每一个字符with open(&apos;a.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f,\ open(&apos;b.txt&apos;,&apos;w+&apos;,encoding=&apos;utf-8&apos;) as f1: for line in f: text = line.strip()+&apos;\n&apos; f1.writelines(text)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(五)]]></title>
    <url>%2F2014%2F11%2F19%2Fpython%E5%9F%BA%E7%A1%80(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[#列表,元组,集合 列表在python中是由数个有序的元素组成的数据结构,每一个元素对应一个index索引来隐式标注元素在列表中的位置.是python中最常用的一种数据类型.需要注意的是列表中可以有重复相同的数据. 列表的常用操作:包括索引,切片,增删改查等.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#首先申明3个列表list_all = [&apos;22&apos;,&apos;sylar&apos;,&apos;22&apos;,&apos;open&apos;,&apos;4&apos;,&apos;sklfj&apos;,&apos;open&apos;,16,&apos;sjk113&apos;,&apos;skf_kjdk&apos;,&apos;open&apos;,&apos;skj*&amp;%)&apos;,&apos;f_s2df&apos;]list_num = [1,4,7,3,5,4]list_alp = [&apos;axod&apos;,&apos;sccde&apos;,&apos;lsoM&apos;,&apos;JLKSI&apos;,&apos;KDIiid&apos;]#切片,是用index来获取列表的某个或几个元素,其中多个元素用[start:end:step]来获取,index是从0开始,-1,-2来表示列表的最右的后几位print(list_all[0])print(list_all[2:10:2])print(list_all[7:-1])print(list_all[7:])print(list_all[:7])#append 在列表末尾添加一个值list_alp.append(&apos;append&apos;)print(&apos; append 方法---&gt;:&apos;,list_alp)#count 记录一个值在列表中出现的次数print(&apos; count 方法---&gt;:&apos;,list_all.count(&apos;open&apos;))#copy复制一个列表l_copy = list_all.copy()print(l_copy)#clear清空列表print(l_copy.clear())#extend将两个表合并list_all.extend(list_num)print(&apos; extend 方法---&gt;:&apos;,list_all)#insert插入一个元素,可以指定index来确定元素的位置list_alp.insert(2,&apos;sylar&apos;)print(&apos; insert 方法---&gt;:&apos;,list_alp)#index ,打印列表中某个值的indexprint(&apos; index 方法---&gt;:&apos;,list_all.index(&apos;a&apos;))#pop 删除列表中的元素,默认是最后一个print(&apos; pop 方法---&gt;:&apos;,&apos; pop---&gt;:&apos;,list_all.pop(),&apos; list_all---&gt;:&apos;,list_all)print(&apos; pop 方法---&gt;:&apos;,&apos; pop---&gt;:&apos;,list_all.pop(0),&apos; list_all---&gt;:&apos;,list_all)#remove 删除列表中找到的值,如果有相同的只删除找到的第一个,如果值不存在会引发一个错误print(&apos; remove 方法---&gt;:&apos;,list_all.remove(&apos;open&apos;),&apos; list_all---&gt;:&apos;,list_all)#reverse 将列表的元素进行反向排序print(&apos; reverse 方法---&gt;:&apos;,list_all.reverse(),list_all)#sort按照ASCII码给列表排序print(&apos; 方法---&gt;:&apos;,list_all.sort(),list_all)#补充:一个循环列表比较好用的函数enumerate,可以快速获取列表的元素和对应的indexfor index,item in enumerate(list_all): print(index,item)#或者:for index,item in enumerate(list_all,1): print(index,item) 元组与列表类似的一个数据结构,不同在于元组的元素不能修改.需要注意的是元组的元素不能修改,但是元组的元素的元素是可以修改的. 元组的常用操作切片和列表一样,只是没有了修改元素的方法12345678910111213141516171819#申明元组tup1 = (1,2,3,[&apos;a&apos;,&apos;a&apos;, &apos;b&apos;])#切片print(tup1[0])print(tup1[0:8:2])print(tup1[3:-1])print(tup1[3:])print(tup1[:3])#index获取元素的index值print(tup1.index(2))#count对相同元素进行统计print(tup1.count(5))#补充 元素的元素可以修改,深浅copy的经典案例tup1[-1][1] = &apos;c&apos;print(tup1) 集合由多个无序且不重复的多个元素组成数据结构.所以集合也没有index.通常用来做去重和关系测试工作!集合也是无序的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#申明集合使用set函数.可以是列表元组字符串等数据类型,set_test1 = set(list_num)print(set_test1)set_test2 = set([2,4,45,43,3,6,0,98,9,7,6])print(set_test2)set_test3 = set(&apos;sylar&apos;)print(set_test3)set_test4 = set([1,3,5])print(&apos;set4&apos;,set_test4)#集合常用操作,增删和关系测试#add添加元素set_test1.add(45)print(set_test1)#copy,复制set_copy = set_test1.copy()print(set_copy)#clear清空set_copy = set_copy.clear()print(set_copy)#difference差集,在set_test1中有在set_test2没有a = set_test1.difference(set_test2)print(a)#intersection交集,在set_test1中有在set_test2也有的.a = set_test1.intersection(set_test2)print(set_test1 &amp; set_test2)print(a)#isdisjoint,在set_test4和set_test5中都没有相同的元素.则返回True,反之set_test5 = set([2,4,6])a = set_test4.isdisjoint(set_test5)print(a)#issuperset父集issubset子集,判断一个集合是不是另外一个集合的父集或者子集.返回值True或者Falsea = set_test1.issuperset(set_test4)print(a)a = set_test4.issubset(set_test1)print(a)#pop删除并返回任意一个元素a = set_test1.pop()print(a)#remove删除指定元素print(set_test1.remove(7))#symmetric_difference对称差集,去除两个集合中都有的元素之后的结果print(set_test1.symmetric_difference(set_test2))#union并集两个集合组合到一起的结果print(set_test1.union(set_test2))#update只能把可迭代的对象加入原集合set_test1.update(set_test5)print(set_test1)#数学运算符&amp;交集,|并集,- 差集,^ 对称差集print(set_test1 &amp; set_test2)print(set_test1 | set_test2)print(set_test1 - set_test2)print(set_test1 ^ set_test2) 补充上面3种数据结构都可以使用的1234#in判断元素是否在集合中for i in set_test2: print(i)if 0 not in list_num:print(&apos;yes&apos;)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(四)]]></title>
    <url>%2F2014%2F11%2F16%2Fpython%E5%9F%BA%E7%A1%80(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[字符串处理1msg = &apos;my name is sylar&apos; capitalize方法,将字符串的首字母大写1print &apos;capitalize方法:&apos;, msg.capitalize() swapcase方法用于对字符串的大小写字母进行转换。upper1234print &apos;swapcase方法:&apos;, msg.swapcase()print &apos;upper方法:&apos;,msg.upper()msq_lower = msg.upper()print &apos;lower方法:&apos;,msq_lower, msq_lower.lower() 所有单词都是以大写开始，其余字母均为小写(见 istitle())1print &apos;title方法:&apos;,msg.title() count方法,查询子串出现的次数12print msg.count(&apos;name&apos;)print &apos;count方法:&apos;, msg.count(&apos;a&apos;) center:用指定的字符,将字符串填充到指定的长度左1print &apos;center方法:&apos;, msg.center(40,&apos;x&apos;) ljust将原字符串左对齐,并使用空格填充至指定长度的新字符串。如果指定的长度小于原字符串的长度则返回原字符.填充字符，默认为空格。1print &apos;ljust方法:&apos;, msg.ljust(20,&apos;x&apos;) rjust将原字符串右对齐,并使用空格填充至长度 width 的新字符串。如果指定的长度小于字符串的长度则返回原字符串。1print &apos;rjust方法:&apos;, msg.rjust(20,&apos;x&apos;) 字符编码 #decode,encode123456msg2 = &apos;我是sylar&apos;msg3 = u&apos;我是sylar&apos;print &apos;msg2:&apos;,msg2,type(msg2),&apos;\tmsg3:&apos;, msg3, type(msg3)msg2 = msg2.decode(&apos;utf-8&apos;)msg3 = msg3.encode(&apos;utf8&apos;)print &apos;msg2.decode:&apos;,msg2, type(msg2), &apos;\tmsg3.decode:&apos;,msg3,type(msg3) endswith,startswith 查找字符串的开始和结束位置的字符串1234print msg.endswith(&apos;sylar&apos;)print msg.endswith(&apos;tom&apos;)print msg.startswith(&apos;my&apos;)print msg.startswith(&apos;MY&apos;) expandtabs 将制表符TAB替换为空格 windows这里不太明显.Linux下面是改变制表符的长度12msg_expandtabs = &apos;my name is\tsylar&apos;print &apos;expandtabs方法:&apos;,msg.expandtabs() find,index方法 #index检查是否包含一个子串位置码和find方法一样,但是会报告一个错误返回!,find方法不会返回错误返回-11print &apos;index方法:&apos;,msg.index(&apos;y&apos;) print ‘index方法返回错误:’,msg.index(‘sylra’)12print &apos;find方法:&apos;,msg.find(&apos;y&apos;)print &apos;find方法没找到:&apos;,msg.find(&apos;tom&apos;) rfind,rindex返回字符串最后一次出现的位置 find,index是第一次出现的位置12print &apos;rfind方法:&apos;,msg.rfind(&apos;y&apos;)print &apos;rindex方法:&apos;,msg.rindex(&apos;y&apos;) format 格式化输出字符串12345msg.format()age = &apos;88&apos;name = &apos;sylar&apos;print(&apos;&#123;0&#125; is &#123;1&#125; years old. &apos;.format(name, age)) #输出参数print(&apos;&#123;0&#125; is a girl. &apos;.format(name)) 字符串类型判断12345678age_num = age.isalnum() #所有字符都是数字或者字母age_dig = age.isdigit() #所有字符都是数字age_alp = age.isalpha() #所有字符都是字母age_low = age.islower() #所有字符都是小写age_spc = age.isspace() #所有字符都是空白字符age_tit = age.istitle() #所有单词都是首字母大写，像标题age_upp = age.isupper() #所有字符都是大写print &apos;字符串类型判断:&apos;,age_num,age_dig,age_alp,age_low,age_spc,age_tit,age_upp lstrip方法用于 截掉字符串左边的空格或指定字符。rstrip 删除 string 字符串末尾的指定字符,strip方法用于移除字符串头尾指定的字符（默认为空格）1234msg_strip = &apos;xxxkslfsjflsjxxx&apos;print &apos;lstrip方法:&apos;, msg_strip.lstrip(&apos;x&apos;)print &apos;rstrip方法:&apos;,msg_strip.rstrip(&apos;x&apos;)print &apos;strip方法:&apos;,msg_strip.strip(&apos;x&apos;) 截取指定长度的字符串，原字符串右对齐，前面填充01print &apos;zfill方法:&apos;,msg.zfill(10) replace方法 替换字符串中的字符串,如果指定第三个参数count，则替换不超过 count 次12print &apos;replace方法&apos;,msg.replace(&apos;is&apos;,&apos;\033[31;1mis\033[0m&apos;)print &apos;replace方法&apos;,msg.replace(&apos;is&apos;,&apos;\033[31;1m%s\033[0m&apos;%name) join将序列中的元素以指定的字符连接生成一个新的字符串123join_list = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;]msg_join =&apos;&apos;.join(join_list)print &apos;join方法:&apos;, msg_join ,type(msg_join) split,rsplit 将字符串格式化为列表,不指定切割字符默认为空格,还可以指定切割次数,split 从左往右,rsplit从右向左（默认为空格）1234msg_spt = msg.split(&apos;y&apos;,1)print msg_spt,type(msg_spt),msg_spt[0] #当列表内有中文是,直接打印列表返回Unicode编码,取值时则返回中文msg_spt = msg.rsplit(&apos;y&apos;,1)print msg_spt,type(msg_spt),msg_spt[0] partition 方法 将字符串划为元祖 根据指定的分隔符将字符串进行分割。12print &apos;partition方法:&apos;, msg.partition(&apos;y&apos;), type(msg.partition(&apos;y&apos;))print &apos;rpartition方法:&apos;, msg.rpartition(&apos;y&apos;),type(msg.rpartition(&apos;y&apos;)) splitlines按照行分隔，返回一个包含各行作为元素的列表，如果 num 指定则仅切片 num 个行12msg_splitlines=&apos;1\n2\n3\n4&apos;print &apos;splitlines&apos;,msg_splitlines.splitlines() translate()根据参数table给出的表(包含 256 个字符)转换字符串的字符, 要过滤掉的字符放到 del 参数中。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(三)]]></title>
    <url>%2F2014%2F11%2F12%2Fpython%E5%9F%BA%E7%A1%80(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[loops循环语句一 if语句,if语句配合else使用,可以没有else. 单分支if语句 1234age = input(&apos;Age:&apos;)password = &apos;67&apos;if age == password: print(&apos;==&apos;) 多分支语句 1234567891011age = int(input(&apos;Age:&apos;))password = 67if age == password: print(&apos;==&apos;)if age &gt; password: print(&apos;&gt;&apos;)if age &lt; password: print(&apos;&lt;&apos;)else: print(&apos;age error&apos;)#这个例子并不符合逻辑,只是为了举例 需要注意的是else语句是否执行,是判断同级上一个if语句条件不满足就执行else,在上一个if前面的if并不影响else的执行.所以就应该使用elif 12345678910age = int(input(&apos;Age:&apos;))password = 67if age == password: print(&apos;==&apos;)elif age &gt; password: print(&apos;&gt;&apos;)elif age &lt; password: print(&apos;&lt;&apos;)else: print(&apos;age error&apos;) 二 while语句,无限循环使用break语句跳出(可以没有跳出语句,但是就要注意设置while的跳出条件,不然会死循环) 满足自定条件跳出 123456count = 0while True: count = count + 1 print(count) if count == 20: break 定义退出的条件 1234count = 0while count &lt; 10: count = count + 1 print(count) while也可以配合else执行一些特殊的代码 1234567891011121314151617181920password = 67count = 0while count &lt; 5: count = count + 1 age = input(&apos;Age:&apos;) if age.isdigit(): age = int(age) if age == password: print(&apos;Very Good!&apos;) break elif age &gt; password: print(&apos;&gt;&apos;) else: print(&apos;&lt;&apos;) else: print(&apos;The input is not the digit, the program exits&apos;) breakelse: print(&apos;Try it too many times&apos;)print(&apos;Always executed&apos;) 三 for语句类似while语句,for是遍历一个条件,不会形成死循环(相对)所以可以不用设置退出条件. 简单的for循环, 12345678for i in range(10): i = i + 1 print(i) for i in [1, 6, 22, 48, 10, 8, 33 ]: print(i) if i == 8: break 合理使用while和for能优化代码 123456789101112131415passwd = 67for i in range(10): age = input(&apos;Age: &apos;) if age.isdigit(): age = int(age) if age &gt;passwd: print(&apos;&gt;&apos;) elif age &lt; passwd: print(&apos;&lt;&apos;) else: print(&apos;Very Good!&apos;) breakelse: print(&apos;The input is not the digit, the program exits&apos;)print(&apos;Always executed&apos;) 补充: continue和break的区别,continue是跳过本次循环进行下一次循环,break是跳出整个循环语句 123456789101112count = 100for i in range(10): print(&apos;In this loop count is :&apos;,count) a = input(&apos;Whatever:&apos;) if a == &apos;c&apos;: continue if a == &apos;b&apos;: break if a == &apos;q&apos;: exit() count = count + 1print(&apos;Other things!&apos;) return跳出多重循环(其实ruturn不是这个作用,但是现在暂时只能想到这个办法比较简单) 123456789count = 0for i in range(10): print(&apos;-loop- i: &apos;,i) for j in range(10): print(&apos;--loop-- j: &apos;, j) for k in range(10): print(&apos;---loop--- k:&apos;, k) count = count + 1print(count) 这个循环会让count累加到1000,假如我们给定到达888的时候跳出该怎么做呢?123456789101112131415flag = Falsecount = 0while not flag: for i in range(10): print(&apos;-loop- i: &apos;,i) while not flag: for j in range(10): print(&apos;--loop-- j: &apos;, j) while not flag: for k in range(10): print(&apos;---loop--- k:&apos;, k) count = count + 1 if count == 888: print(count) flag = True 上面这种做法,我们可以看到i和j还是循环多了两次,因此在每层循环必须都判断一下count的数值.正确的做法是封装一个函数12345678910111213def mul_loops(): flag = 0 for i in range(10): print(&apos;-loop- i: &apos;, i) for j in range(10): print(&apos;--loop-- j: &apos;, j) for k in range(10): print(&apos;---loop--- k:&apos;, k) if flag == 888: return flag flag = flag + 1a = mul_loops()print(a)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(二)]]></title>
    <url>%2F2014%2F11%2F09%2Fpython%E5%9F%BA%E7%A1%80(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[编码,深浅copyencode,decode在python2中使用的一些迷糊,python3中更容易理解要理解encode和decode,首先我们要明白编码,字符和二进制的相关概念,简单来说,计算机的产生和设计只能进行二进制的运算,聪明的先辈们发明了ASCii编码用不同的二进制来表示不同英文字符实现.后来由于各国计算机的普及和推广,由于语言的原因产生了:Unicode,GB2312,UTF-8等不同的字符编码集. 在python3中对字符数据是使用的str类型,二进制数据使用的是bytes.而我们要让计算机能够处理字符串就必须能将字符转换为二进制数据(我们在idle中编写的代码这个步骤由解释器处理了).有时候为了我们在编写代码时能灵活的处理数据,就需要字符和二进制数据的转换.就产生了encode和decode方法,两者的关系如下: 123456789101112131415161718192021222324#str-&gt;bytes:encode编码#bytes-&gt;str:decode解码str_a = str(&apos;我是二进制&apos;)#编码,bytes_uft8 = str_a.encode(encoding=&apos;utf-8&apos;) #字符串转换为utf-8的二进制print(bytes_uft8,type(bytes_uft8))bytes_gbk = str_a.encode(encoding=&apos;gbk&apos;) #字符串转换为gbk的二进制print(bytes_gbk,type(bytes_gbk))#解码str_uft8 = bytes_uft8.decode(encoding=&apos;utf-8&apos;) #二进制转换为utf的字符串print(str_uft8,type(str_uft8))str_gbk = bytes_gbk.decode(encoding=&apos;gbk&apos;) #二进制转换为gbk的字符串print(str_gbk,type(str_gbk))#保存到文件中,utf-8.txt将编码换为GBK会乱码,是因为GBK不兼容utf8.#但是utf-8兼容gbk,所以gbk.txt用utf-8不会乱码.with open(&apos;gbk.txt&apos;,&apos;wb&apos;) as f,open(&apos;utf-8.txt&apos;,&apos;wb&apos;) as f1: f.write(bytes_gbk) f1.write(bytes_uft8) 编码是将字符串转换成二进制编码.解码是将二进制编码转换为字符串.python2中默认使用ASCII编码,python3使用Unicode获取系统默认编码:12import sysprint(sys.getdefaultencoding()) 简单来说就是Unicode是二进制字符编码,兼容GBK,UTF-8,所有字符编码要转换都需要通过Unicode来作为桥梁来相互转换.在python解释器使用的字符编码是Unicode.中国使用的操作系统默认编码是GBK.而我们常用程序又有可能使用的其它国家的编码.所以这之间就存在一个编码和解码的过程. 所以我们记住utf8的python字符可以转化为gbk,big5等编码转换,但是要吧gbk,big5等编码转换为utf8必须要知道字符原来使用的那种编码集.不知道原来的字符集就没有办法转化为utf8.12345678910#打开test.txt切换编码为utf8,gbk,big5可以看到不同效果a = &apos;中國&apos;b_utf8 =a.encode(encoding=&apos;utf8&apos;)b_big5 =a.encode(encoding=&apos;big5&apos;)b_gbk = a.encode(encoding=&apos;gbk&apos;)with open(&apos;test.txt&apos;,&apos;wb&apos;) as f: f.write(b_utf8) f.write(b_big5) f.write(b_gbk) 最后:1, python3是支持直接使用UTF-8(因为UTF-8是Unicode的一个扩展集,能够自动转换),但是在不同语言系的操作系统中可能会乱码.所以知道为什么有时候编写程序的时候全是乱码b’\xxx\xxx’的数据了吧,这是字符文本在Unicode中的编码2, 关于为什么输出的是\xxx的数据.这个又涉及到二进制和16进制的转换了,我猜想应该是Unicode是使用16进制来记录二进制.3, html中的utf8使用/%做占位符,python中的utf8使用\x做占位符.所以网页中的链接中的汉字在python中要特殊处理4,要解码必须要知道原来的字符是使用哪种文字编码. 深浅copy浅copy的方式,浅copy也是一种面向对象的实现,初学者可以这样去理解浅copy只是复制了对象的内存地址,对于一些复杂的数据类型对象使用的内存地址进行.当列表中包含一个子列表时,复制的也是这个子列表的内存地址.12345678910#申明一个列表human = [&apos;name&apos;,[&apos;age&apos;,18]]#使用几种浅copy方式复制数据p1 = human[:] #切片的方式p2 = list(human) #使用内置函数import copyp3 = copy.copy(human) #使用copy模块浅copy方法p4 = human.copy() #使用列表的copy方法,其实也是引用的copy模块浅copy的方法 这时候我们假如human是同一个生日的同学类型.他们的name属性不一致,但是随着时间的变化,年龄都会增长,所以他们的age的变化都会一致 12345678p1[0] = &apos;dongxie&apos;p2[0] = &apos;xidu&apos;p3[0] = &apos;nandi&apos;p4[0] = &apos;beigai&apos;print(p1,p2,p3,p4)#这时候不管修改谁的年龄,大家年龄都会变p1[1][1] = 23print(p1,p2,p3,p4)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础(一)]]></title>
    <url>%2F2014%2F11%2F07%2Fpython%E5%9F%BA%E7%A1%80(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[1. python文件主程序入口文件一般来要申明python路径,编码信息,作者说明等:12345#!/usr/bin/env python# _*_ coding: utf-8 _*_# Author: sylar# Date:xxxx# Dec: xxx 2. python中相同的内存数据只会保存一份,变量赋值是通过复制内存地址进行.A复制给B.B是将A的内存地址复制一份,A重新赋值内存地址将变化,所以B不会改变.(因此造成了深浅copy的问题.)1234567a = 1b = aprint(id(a),id(b))print(a,b)a = a + 1print(id(a),id(b))print(a,b) 3. python3和python2的区别(比较简单的,复杂的会在后面慢慢深入):(1)python2默认已unicode编码处理代码,python3默认以utf-8处理代码.(2)python3没有raw_input只input,python2中不建议使用input(3)python3不能使用&lt;&gt;,只能使用!=来表示不等于 4. python中单引号’和双引号”作用完全一样.5. 变量命名只能使用字母数字和下划线,多个单词组合的变量名建议用_分割单词.全大写变量名为常量(约定俗成,变量本身是可以修改的).####6. 字符串格式化方法(1)+号拼接 12345678name = input(&apos;name:&apos;)age = input(&apos;age:&apos;)info = &apos;&apos;&apos;------------info of &apos;&apos;&apos; + name + &apos;&apos;&apos;------------Name: &apos;&apos;&apos; + name + &apos;&apos;&apos;Age: &apos;&apos;&apos; + ageprint(info) (2)%s格式化输出(注意%d,%s,%f的数据类型不同.input会默认接受数据类型为字符串) 123456789name = input(&apos;name:&apos;)age = input(&apos;age:&apos;)info = &apos;&apos;&apos;------------info of %s------------Name: %sAge: %s&apos;&apos;&apos;%(name,name,age)print(info) (3)format方法 123456789name = input(&apos;name:&apos;)age = input(&apos;age:&apos;)info = &apos;&apos;&apos;------------info of &#123;who&#125;------------Name: &#123;who&#125;Age: &#123;how_old&#125;&apos;&apos;&apos;.format(who=name,how_old=age)print(info) 123456789#不建议使用name = input(&apos;name:&apos;)age = input(&apos;age:&apos;)info = &apos;&apos;&apos;------------info of &#123;0&#125;------------Name: &#123;0&#125;Age: &#123;1&#125;&apos;&apos;&apos;.format(name,age)print(info) 7. type查看数据类型,help查看帮助, dir查看内置方法,id查看对象在解释器中的内存地址]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2013%2F12%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
